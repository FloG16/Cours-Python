Bonjour, je suis Arnaud Legout et nous allons passer les prochaines semaines de ce MOOC ensemble. 
Dans cette vid√©o, nous allons d√©couvrir les notions d'objet, de variable et de typage dynamique. 
Pourquoi est-ce que ces notions sont tellement importantes en Python ? Parce qu'en Python, tout est un objet. 
Par cons√©quent, dans vos programmes, vous aurez √† manipuler de nombreux objets. Et le moyen en Python de manipuler ces objets, 
c'est de leur donner un nom par l'interm√©diaire de variables. On dit que les variables r√©f√©rencent les objets. 
Regardons maintenant cette notion d'objet. Dans un programme informatique, un objet est un morceau de code qui va contenir des donn√©es. 
Mais il va √©galement contenir un ensemble de m√©canismes qui permettent de manipuler ces donn√©es et que l'on appelle m√©thodes. 
Les objets ont tous un type. Le type est le comportement par d√©faut qui va √™tre d√©fini pour ces objets. Par cons√©quent, 
le type va permettre de d√©finir les donn√©es et les m√©thodes qui vont √™tre associ√©es √† cet objet. Prenons l'analogie d'une cha√Æne de montage de voitures. 
Lorsque vous avez une usine, votre usine va construire des voitures, et c'est cette usine qui va d√©finir un ensemble de comportements que toutes les voitures 
qui vont sortir de la cha√Æne de montage vont avoir. Donc par exemple, la puissance du moteur, le fait que votre voiture va avoir des clignotants, des acc√©l√©rateurs, 
vont √™tre d√©termin√©s par votre cha√Æne de montage. On peut donc dire que la cha√Æne de montage d√©termine le type des voitures qui vont sortir de cette cha√Æne
et que la voiture est l'objet qui sort de cette cha√Æne de montage. Revenons maintenant √† nos programmes informatiques, √† nos objets informatiques. 
Je vais repr√©senter l'ensemble des objets que l'on a dans la m√©moire de l'ordinateur. Maintenant, cr√©ons un objet, cr√©ons notre premier objet python. 
Pour cela, nous allons cr√©er un objet de type cha√Æne de caract√®res, nous reviendrons largement sur ce type d'objet dans la suite. Pour cr√©er un objet 
cha√Æne de caract√®res vous mettez deux apostrophes et entre les apostrophes, vous mettez la cha√Æne de caract√®res que vous voulez cr√©er. 
Lorsque vous appuyez sur le retour chariot, l'interpr√©teur Python va cr√©er cet objet cha√Æne de caract√®res. Nous voyons que cet objet a des donn√©es 
associ√©es c'est le mot "spam" et cet objet a √©galement un ensemble de m√©thodes comme par exemple la m√©thode upper(). D'o√π viennent les m√©thodes 
de la cha√Æne de caract√®res puisque nous n'avons rien d√©fini nous-m√™mes ? En fait, toutes les m√©thodes de la cha√Æne de caract√®res viennent 
gr√¢ce √† son type le type "cha√Æne de caract√®res". Maintenant, nous pouvons appeler les m√©thodes sur ces objets. Pour appeler une m√©thode sur un objet, 
c'est tr√®s simple, il suffit d'utiliser la notation "point". Pour cela, nous allons mettre l'objet "point" la m√©thode que l'on veut appeler. 
et n'oublions pas de mettre les parenth√®ses ouvrante et fermante qui permettent de d√©clencher l'ex√©cution de la m√©thode upper() sur l'objet "spam". 
Maintenant que nous avons vu cette notion d'objet, regardons comment nommer les objets. On dit les r√©f√©rencer. Pour cela, on va affecter un objet 
√† un nom de variable particulier avec une notation que l'on appelle la notation d'affectation. Donc supposons que nous voulions nommer l'entier 1, 
nous allons √©crire note "√©gale" 1, ce qui veut dire que la variable de nom "note" va maintenant r√©f√©rencer l'objet 1. On pourra ainsi manipuler 
cet objet par l'interm√©diaire de ce nom de variable. Un nom de variable en Python peut √™tre d√©fini par n'importe quelle lettre en minuscule, 
n'importe quelle lettre en majuscule, les entiers allant de 0 √† 9 et √©galement le caract√®re tiret bas que l'on appelle √©galement "underscore". 
Un nom de variable peut commencer par une lettre, √ßa peut √©galement commencer par l'underscore mais √ßa ne peut pas commencer par un chiffre. 
Un nom de variable prend en compte la casse, c'est-√†-dire qu'un nom en minuscule et un nom en majuscule vont repr√©senter deux variables diff√©rentes. 
Pour finir, il est tr√®s important en Python de donner des noms de variable qui sont explicites. Par exemple, moyenne_age_francais est un bon nom de variable,
meilleur que moy_age_f et bien meilleur que simplement la variable x. Il est tr√®s important de donner de donner des bons noms de variable puisque √ßa participe 
√† la documentation automatique de votre code. Et nous verrons dans les prochaines vid√©os et les semaines suivantes que Python offre de nombreux m√©canismes 
pour faciliter ce nommage explicite des objets que l'on manipule. Maintenant que nous avons vu les notions d'objet et de variable, parlons de la derni√®re 
notion importante de cette vid√©o, qui est le typage dynamique. Je vous repr√©sente ici l'espace des objets comme nous avons vu pr√©c√©demment qui va contenir 
tous les objets que nous avons dans l'ordinateur, et √©galement l'espace des variables qui repr√©sente les variables qui vont r√©f√©rencer les objets 
dans notre ordinateur. Nous verrons dans la suite et dans les semaines qui viennent que cet espace des variables, on appelle √ßa en fait un espace de nommage. 
Supposons maintenant que je fasse a √©gale 3 ce qui veut dire que ma variable a va r√©f√©rencer l'entier 3. Lorsque je fais un retour chariot, 
Python va ex√©cuter 3 op√©rations. La premi√®re op√©ration va consister √† cr√©er l'entier 3. Donc c'est un objet qui est cr√©√© dans l'espace des objets. 
Puis il va cr√©er une variable a dans l'espace des variables. Et pour finir, il va cr√©er une r√©f√©rence entre cette variable a et l'entier 3. Maintenant,
supposons que je fasse a √©gale spam. Python va effectuer la m√™me suite d'op√©rations et il va cr√©er un objet de type cha√Æne de caract√®res qui s'appelle spam,
puis il va cr√©er une variable a mais la variable a existe d√©j√† donc il va simplement d√©r√©f√©rencer cette variable a, et lui faire r√©f√©rencer 
l'objet cha√Æne de caract√®res spam. Donc ici on voit que cette notion de typage dynamique est tr√®s importante. En fait, qu'est-ce que √ßa veut dire 
le typage dynamique ? √áa veut dire qu'en Python le type n'est pas li√© √† la variable qui r√©f√©rence l'objet mais est li√© √† l'objet. En fait, 
Python est un langage que l'on appelle un langage √† typage fort, √ßa veut dire que le typage est li√© aux objets et que l'objet va garder le m√™me type 
durant toute l'ex√©cution du programme. Par contre, la variable, elle, peut r√©f√©rencer des objets qui vont √™tre de type diff√©rent en cours d'ex√©cution. 
Pour finir, si je fais del de a, √ßa va me permettre de supprimer la variable a de mon espace des variables. Si mon objet n'a plus de r√©f√©rence, 
on a un m√©canisme en Python qui s'appelle un m√©canisme de garbage collector qui va lib√©rer la m√©moire de l'ordinateur une fois que les objets ne sont plus r√©f√©renc√©s.
Dans cette vid√©o, nous avons introduit les notions d'objet, de variable et de typage dynamique. Ce sont des notions cl√© en Python parce que comme nous l'avons vu 
en Python tout est un objet, et par cons√©quent, pour pouvoir manipuler ces objets, il faut √™tre capable de leur donner un nom, et on leur donne ce nom 
par le m√©canisme de r√©f√©rencement qui consiste √† donner un nom de variable qui est √©gale √† un objet. √Ä bient√¥t !

---------------------------------------------------------------------
Noms de variables
Compl√©ment - niveau basique

Revenons sur les noms de variables autoris√©s ou non.

Les noms les plus simples sont constitu√©s de lettres. Par exemple :

factoriel = 1

On peut utiliser aussi les majuscules, mais attention cela d√©finit une variable diff√©rente. Ainsi :

Factoriel = 100

factoriel == Factoriel

Le signe == permet de tester si deux variables ont la m√™me valeur. Si les variables ont la m√™me valeur, le test retournera True, et False sinon. On y reviendra bien entendu.
Conventions habituelles

En r√®gle g√©n√©rale, on utilise uniquement des minuscules pour d√©signer les variables simples (ainsi d'ailleurs que pour les noms de fonctions), les majuscules sont r√©serv√©es en principe pour d'autres sortes de variables, comme les noms de classe, que nous verrons ult√©rieurement.

Notons qu'il s'agit uniquement d'une convention, ceci n'est pas impos√© par le langage lui-m√™me.

Pour des raisons de lisibilit√©, il est √©galement possible d'utiliser le tiret bas _ dans les noms de variables. On pr√©f√®rera ainsi :

age_moyen = 75 # oui

plut√¥t que ceci (bien qu'autoris√© par le langage) :

AgeMoyen = 75 # autoris√©, mais non

On peut √©galement utiliser des chiffres dans les noms de variables comme par exemple :

age_moyen_dept75 = 80

avec la restriction toutefois que le premier caract√®re ne peut pas √™tre un chiffre, cette affectation est donc refus√©e :

75_age_moyen = 80 # erreur de syntaxe

Le tiret bas comme premier caract√®re

Il est par contre, possible de faire commencer un nom de variable par un tiret bas comme premier caract√®re ; toutefois, √† ce stade, nous vous d√©conseillons d'utiliser cette pratique qui est r√©serv√©e √† des conventions de nommage bien sp√©cifiques.

_autorise_mais_deconseille = 'Voir le PEP 008'

Et en tout cas, il est fortement d√©conseill√© d'utiliser des noms de la forme __variable__ qui sont r√©serv√©s au langage. Nous reviendrons sur ce point dans le futur, mais regardez par exemple cette variable que nous n'avons d√©finie nulle part mais qui pourtant existe bel et bien :

__name__  # ne d√©finissez pas vous-m√™me de variables de ce genre

Ponctuation

Dans la plage des caract√®res ASCII, il n'est pas possible d'utiliser d'autres caract√®res que les caract√®res alphanum√©riques et le tiret bas. Notamment le tiret haut - est interpr√©t√© comme l'op√©ration de soustraction. Attention donc √† cette erreur fr√©quente :

age-moyen = 75  # erreur : en fait python l'interpr√®te comme 'age - moyen = 75'

Caract√®res exotiques

En Python 3, il est maintenant aussi possible d'utiliser des caract√®res Unicode dans les identificateurs :

# les caract√®res accentu√©s sont permis

nom_√©l√®ve = "Jules Maigret"

# ainsi que l'alphabet grec

from math import cos, pi as œÄ

Œ∏ = œÄ / 4

cos(Œ∏)

Tous les caract√®res Unicode ne sont pas permis - heureusement car cela serait source de confusion. Nous citons dans les r√©f√©rences les documents qui pr√©cisent quels sont exactement les caract√®res autoris√©s.

# ce caract√®re n'est pas autoris√©, car il

# est consid√©r√© comme un signe math√©matique (produit)

‚àè = 10

# ce caract√®re est encore diff√©rent, c'est aussi

# un pi grec mais pas le m√™me, cette fois-ci

# c'est un nom de variable acceptable mais 

# il n'est pas d√©fini

ùûü

Conseil

Il est tr√®s vivement recommand√© :

    tout d'abord de coder en anglais ;
    ensuite de ne pas d√©finir des identificateurs avec des caract√®res non ASCII, dans toute la mesure du possible , voyez par exemple la confusion que peut cr√©er le fait de nommer un identificateur œÄ ou ùûü ou ‚àè ;
    enfin si vous utilisez un encodage autre que UTF-8, vous devez bien sp√©cifier l'encodage utilis√© dans votre fichier source ; nous y reviendrons en deuxi√®me semaine.

Pour en savoir plus

Pour les esprits curieux, Guido van Rossum, le fondateur de Python, est le co-auteur d'un document qui d√©crit les conventions de codage √† utiliser dans la biblioth√®que standard Python. Ces r√®gles sont plus restrictives que ce que le langage permet de faire, mais constituent une lecture int√©ressante si vous projetez d'√©crire beaucoup de Python.

Voir dans le PEP 008 la section consacr√©e aux r√®gles de nommage - (en anglais)

Voir enfin, au sujet des caract√®res exotiques dans les identificateurs :

    le PEP 3131 qui d√©finit les caract√®res exotiques autoris√©s, et qui repose √† son tour sur
    http://www.unicode.org/reports/tr31/ (tr√®s technique !)

---------------------------------------------------------------------------------------------
Les mots-cl√©s de Python
Mots r√©serv√©s

Il existe en Python certains mots sp√©ciaux, qu'on appelle des mots-cl√©s, ou keywords en anglais, qui sont r√©serv√©s et ne peuvent pas √™tre utilis√©s comme identifiants, c'est-√†-dire comme un nom de variable.

C'est le cas par exemple pour l'instruction if, que nous verrons prochainement, qui permet bien entendu d'ex√©cuter tel ou tel code selon le r√©sultat d'un test.

variable = 15

if variable <= 10:

    print("en dessous de la moyenne")

else:

    print("au dessus")

√Ä cause de la pr√©sence de cette instruction dans le langage, il n'est pas autoris√© d'appeler une variable if.

# interdit, if est un mot-cl√©

if = 1

Liste compl√®te

Voici la liste compl√®te des mots-cl√©s :
  	  	  	  	 
False 	await 	else 	import 	pass
None 	break 	except 	in 	raise
True 	class 	finally 	is 	return
and 	continue 	for 	lambda 	try
as 	def 	from 	nonlocal 	while
assert 	del 	global 	not 	with
async 	elif 	if 	or 	yield

Nous avons indiqu√© en gras les nouveaut√©s par rapport √† Python 2 (sachant que r√©ciproquement exec et print ont perdu leur statut de mot-cl√© depuis Python 2, ce sont maintenant des fonctions).

Il vous faudra donc y pr√™ter attention, surtout au d√©but, mais avec un tout petit peu d'habitude vous saurez rapidement les √©viter.

Vous remarquerez aussi que tous les bons √©diteurs de texte supportant du code Python vont colorer les mots-cl√©s diff√©remment des variables. Par exemple, IDLE colorie les mots-cl√©s en orange, vous pouvez donc tr√®s facilement vous rendre compte que vous allez, par erreur, en utiliser un comme nom de variable.

Cette fonctionnalit√©, dite de coloration syntaxique, permet d'identifier d'un coup d'≈ìil, gr√¢ce √† un code de couleur, le r√¥le des diff√©rents √©l√©ments de votre code : variables, mots-cl√©s, etc. D'une mani√®re g√©n√©rale, nous vous d√©conseillons fortement d'utiliser un √©diteur de texte qui n'offre pas cette fonctionnalit√© de coloration syntaxique.
Pour en savoir plus

On peut se reporter √† cette page :

https://docs.python.org/3/reference/lexical_analysis.html#keywords


-------------------------------------------------------------------------------------
Un peu de calcul sur les types
Compl√©ment - niveau basique
La fonction type

Nous avons vu dans la vid√©o que chaque objet poss√®de un type. On peut tr√®s simplement acc√©der au type d'un objet en appelant une fonction built-in, c'est-√†-dire pr√©d√©finie dans Python, qui s'appelle, eh bien oui, type.

On l'utilise tout simplement comme ceci :

type(1)

type('spam')

Cette fonction est assez peu utilis√©e par les programmeurs exp√©riment√©s, mais va nous √™tre utile √† bien comprendre le langage, notamment pour manipuler les valeurs num√©riques.
Types, variables et objets

On a vu √©galement que le type est attach√© √† l'objet et non √† la variable.

x = 1

type(x)

# la variable x peut r√©f√©rencer un objet de n'importe quel type

‚Äã

x = [1, 2, 3]

type(x)

Compl√©ment - niveau avanc√©
La fonction isinstance

Une autre fonction pr√©d√©finie, voisine de type mais plus utile dans la pratique, est la fonction isinstance qui permet de savoir si un objet est d'un type donn√©. Par exemple :

isinstance(23, int)

√Ä la vue de ce seul exemple, on pourrait penser que isinstance est presque identique √† type ; en r√©alit√© elle est un peu plus √©labor√©e, notamment pour la programmation objet et l'h√©ritage, nous aurons l'occasion d'y revenir.

On remarque ici en passant que la variable int est connue de Python alors que nous ne l'avons pas d√©finie. Il s'agit d'une variable pr√©d√©finie, qui d√©signe le type des entiers, que nous √©tudierons tr√®s bient√¥t.

Pour conclure sur isinstance, cette fonction est utile en pratique pr√©cis√©ment parce que Python est √† typage dynamique. Aussi il est souvent utile de s'assurer qu'une variable pass√©e √† une fonction est du (ou des) type(s) attendu(s), puisque contrairement √† un langage typ√© statiquement comme C++, on n'a aucune garantie de ce genre √† l'ex√©cution. √Ä nouveau, nous aurons l'occasion de revenir sur ce point.

--------------------------------------------------------------------------------------------------------------------------

Gestion de la m√©moire
Compl√©ment - niveau basique

L'objet de ce compl√©ment est de vous montrer qu'avec Python vous n'avez pas √† vous pr√©occuper de la m√©moire. Pour expliquer la notion de gestion de la m√©moire, il nous faut donner un certain nombre de d√©tails sur d'autres langages comme C et C++. Si vous souhaitez suivre ce cours √† un niveau basique vous pouvez ignorer ce compl√©ment et seulement retenir que Python se charge de tout pour vous :)
Compl√©ment - niveau interm√©diaire
Langages de bas niveau

Dans un langage traditionnel de bas niveau comme C ou C++, le programmeur est en charge de l'allocation - et donc de la lib√©ration - de la m√©moire.

Ce qui signifie que, sauf pour les valeurs stock√©es dans la pile, le programmeur est amen√© :

    √† r√©clamer de la m√©moire au syst√®me d'exploitation en appelant explicitement malloc (C) ou new (C++) ;
    et r√©ciproquement √† rendre cette m√©moire au syst√®me d'exploitation lorsqu'elle n'est plus utilis√©e, en appelant free (C) ou delete (C++).

Avec ce genre de langage, la gestion de la m√©moire est un aspect important de la programmation. Ce mod√®le offre une grande flexibilit√©, mais au prix d'un co√ªt √©lev√© en mati√®re de vitesse de d√©veloppement.

En effet, il est assez facile d'oublier de lib√©rer la m√©moire apr√®s usage, ce qui peut conduire √† √©puiser les ressources disponibles. √Ä l'inverse, utiliser une zone m√©moire non allou√©e peut conduire √† des bugs tr√®s difficiles √† localiser et √† des probl√®mes de s√©curit√© majeurs. Notons qu'une grande partie des attaques en informatique reposent sur l'exploitation d'erreurs de gestion de la m√©moire.
Langages de haut niveau

Pour toutes ces raisons, avec un langage de plus haut niveau comme Python, le programmeur est lib√©r√© de cet aspect de la programmation.

Pour anticiper un peu sur le cours des semaines suivantes, voici ce que vous pouvez garder en t√™te s'agissant de la gestion m√©moire en Python :

    vous cr√©ez vos objets au fur et √† mesure de vos besoins ;

    vous n'avez pas besoin de les lib√©rer explicitement, le "Garbage Collector" de Python va s'en charger pour recycler la m√©moire lorsque c'est possible ;

    Python a tendance √† √™tre assez gourmand en m√©moire, compar√© √† un langage de bas niveau, car tout est objet et chaque objet est assorti de m√©ta-informations qui occupent une place non n√©gligeable. Par exemple, chaque objet poss√®de au minimum :
        une r√©f√©rence vers son type - c'est le prix du typage dynamique ;
        un compteur de r√©f√©rences - le nombre d'autres valeurs (variables ou objets) qui pointent vers l'objet, cette information est notamment utilis√©e, pr√©cis√©ment, par le Garbage Collector pour d√©terminer si la m√©moire utilis√©e par un objet peut √™tre lib√©r√©e ou non.

    un certain nombre de types pr√©d√©finis et non mutables sont impl√©ment√©s en Python comme des singletons, c'est-√†-dire qu'un seul objet est cr√©√© et partag√©, c'est le cas par exemple pour les petits entiers et les cha√Ænes de caract√®res, on en reparlera ;

    lorsqu'on impl√©mente une classe, il est possible de lui conf√©rer cette caract√©ristique de singleton, de mani√®re √† optimiser la m√©moire n√©cessaire pour ex√©cuter un programme.

-----------------------------------------------------------------------------------------------

Typages statique et dynamique
Compl√©ment - niveau interm√©diaire

Parmi les langages typ√©s, on distingue les langages √† typage statique et ceux √† typage dynamique. Ce notebook tente d'√©claircir ces notions pour ceux qui n'y sont pas familiers.
Typage statique

√Ä une extr√©mit√© du spectre, on trouve les langages compil√©s, dits √† typage statique, comme par exemple C ou C++.

En C on √©crira, par exemple, une version simpliste de la fonction factoriel comme ceci :

int factoriel(int n) {
    int result = 1;
    for (int loop = 1; loop <= n; loop++)
        result *= loop;
    return result;
}

Comme vous pouvez le voir - ou le deviner - toutes les variables utilis√©es ici (comme par exemple n, result et loop) sont typ√©es :

    on doit appeler factoriel avec un argument n qui doit √™tre un entier (int est le nom du type entier) ;
    les variables internes result et loop sont de type entier ;
    factoriel retourne une valeur de type entier.

Ces informations de type ont essentiellement trois fonctions :

    en premier lieu, elles sont n√©cessaires au compilateur. En C si le programmeur ne pr√©cisait pas que result est de type entier, le compilateur n'aurait pas suffisamment d'√©l√©ments pour g√©n√©rer le code assembleur correspondant ;
    en contrepartie, le programmeur a un contr√¥le tr√®s fin de l'usage qu'il fait de la m√©moire et du mat√©riel. Il peut choisir d'utiliser un entier sur 32 ou 64 bits, sign√© ou pas, ou construire avec struct et union un arrangement de ses donn√©es ;
    enfin, et surtout, ces informations de type permettent de faire un contr√¥le a priori de la validit√© du programme, par exemple, si √† un autre endroit dans le code on trouve :

#include <stdio.h>

int main(int argc, char *argv[]) {
    /* le premier argument de la ligne de commande est argv[1] */
    char *input = argv[1];
    /* calculer son factoriel et afficher le r√©sultat */
    printf("Factoriel (%s) = %d\n", input, factoriel(input));
    /*                                               ^^^^^

     * ici on appelle factoriel avec une entr√©e de type 'cha√Æne de caract√®res' */
}

alors le compilateur va remarquer qu'on essaie d'appeler factoriel avec comme argument input qui, pour faire simple, est une cha√Æne de caract√®res et comme factoriel s'attend √† recevoir un entier, ce programme n'a aucune chance de compiler.

On parle alors de typage statique, en ce sens que chaque variable a exactement un type qui est d√©fini par le programmeur une bonne fois pour toutes.

C'est ce qu'on appelle le contr√¥le de type, ou type-checking en anglais. Si on ignore le point sur le contr√¥le fin de la m√©moire, qui n'est pas crucial √† notre sujet, ce mod√®le de contr√¥le de type pr√©sente :

    l'inconv√©nient de demander davantage au programmeur (je fais abstraction, √† ce stade et pour simplifier, de langages √† inf√©rence de types comme ML et Haskell) ;
    et l'avantage de permettre un contr√¥le √©tendu, et surtout pr√©coce (avant m√™me de l'ex√©cuter), de la bonne correction du programme.

Cela √©tant dit, le typage statique en C n'emp√™che pas le programmeur d√©butant d'essayer d'√©crire dans la m√©moire √† partir d'un pointeur NULL - et le programme de s'interrompre brutalement. Il faut √™tre conscient des limites du typage statique.
Typage dynamique

√Ä l'autre bout du spectre, on trouve des langages comme, eh bien, Python.

Pour comprendre cette notion de typage dynamique, regardons la fonction suivante somme.

def somme(*largs):

    "retourne la somme de tous ses arguments"

    if not largs:

        return 0

    result = largs[0]

    for i in range(1, len(largs)):

        result += largs[i]

    return result

Naturellement, vous n'√™tes pas √† ce stade en mesure de comprendre le fonctionnement intime de la fonction. Mais vous pouvez tout de m√™me l'utiliser :

somme(12, 14, 300)

liste1 = ['a', 'b', 'c']

liste2 = [0, 20, 30]

liste3 = ['spam', 'eggs']

somme(liste1, liste2, liste3)

Vous pouvez donc constater que somme peut fonctionner avec des objets de types diff√©rents. En fait, telle qu'elle est √©crite, elle va fonctionner s'il est possible de faire + entre ses arguments. Ainsi, par exemple, on pourrait m√™me faire :

# Python sait faire + entre deux cha√Ænes de caract√®res

somme('abc', 'def')

Mais par contre on ne pourrait pas faire

# ceci va d√©clencher une exception √† l'ex√©cution

somme(12, [1, 2, 3])

Il est utile de remarquer que le typage de Python, qui existe bel et bien comme on le verra, est qualifi√© de dynamique parce que le type est attach√© √† un objet et non √† la variable qui le r√©f√©rence. On aura bien entendu l'occasion d'approfondir tout √ßa dans le cours.

En Python, on fait souvent r√©f√©rence au typage sous l'appellation duck typing, de mani√®re imag√©e :

    If it looks like a duck and quacks like a duck, it's a duck.

On voit qu'on se trouve dans une situation tr√®s diff√©rente de celle du programmeur C/C++, en ce sens que :

    √† l'√©criture du programme, il n'y aucun des surco√ªts qu'on trouve avec C ou C++ en mati√®re de d√©finition de type ;
    aucun contr√¥le de type n'est effectu√© a priori par le langage au moment de la d√©finition de la fonction somme ;
    par contre au moment de l'ex√©cution, s'il s'av√®re qu'on tente de faire une somme entre deux types qui ne peuvent pas √™tre additionn√©s, comme ci-dessus avec un entier et une liste, le programme ne pourra pas se d√©rouler correctement.

Il y a deux points de vue vis-√†-vis de la question du typage.

Les gens habitu√©s au typage statique se plaignent du typage dynamique en disant qu'on peut √©crire des programmes faux et qu'on s'en rend compte trop tard - √† l'ex√©cution.

√Ä l'inverse les gens habitu√©s au typage dynamique font valoir que le typage statique est tr√®s partiel, par exemple, en C si on essaie d'√©crire dans un pointeur NULL, le syst√®me d'exploitation ne le permet pas et le programme sort tout aussi brutalement.

Bref, selon le point de vue, le typage dynamique est v√©cu comme un inconv√©nient (pas assez de bonnes propri√©t√©s d√©tect√©es par le langage) ou comme un avantage (pas besoin de passer du temps √† d√©clarer le type des variables, ni √† faire des conversions pour satisfaire le compilateur).

Vous remarquerez cependant √† l'usage, qu'en mati√®re de vitesse de d√©veloppement, les inconv√©nients du typage dynamique sont tr√®s largement compens√©s par ses avantages.
Type hints

Signalons enfin que depuis python-3.5, il est possible d'ajouter des annotations de type, pour expliciter les suppositions qui sont faites par le programmeur pour le bon fonctionnement du code.

Nous aurons l√† encore l'occasion de d√©tailler ce point dans le cours, signalons simplement que ces annotations sont totalement optionnelles, et que m√™me lorsqu'elles sont pr√©sentes elles ne sont pas utilis√©es √† l'ex√©cution par l'interpr√©teur. L'id√©e est plut√¥t de permettre √† des outils externes, comme par exemple mypy, d'effectuer des contr√¥les plus pouss√©s concernant la correction du programme.

